Elm target
==========

[Elm] is a purely functional programming language for single page webapps.
Nirum currently has an experimental implementation for targetting Elm.
Since Elm is only focused to webapps run on web browsers, the compiler
doesn't generate a server from a service definition, but only a client.

[Elm]: http://elm-lang.org/


Caveats
-------

Since the official [`elm-package`][elm-package] does not support any other than
GitHub public repositories to publish Elm packages (as of March 2018),
an Elm package generated by the Nirum compiler also need to be published to
a public repository on GitHub and submitted using `elm-package publish`.

Alternatvely, you could want to use [`elm-install`][elm-install] to install
a private Elm package generated by the Nirum compiler.

Either way, you have to *separate* a repository for a *generated Elm package*
from a repository for a *Nirum source package*, since `elm-install` cannot
compile/recognize a Nirum source package.

[elm-package]: https://github.com/elm-lang/elm-package
[elm-install]: https://github.com/gdotdesign/elm-github-install


Settings
--------

The below settings can be configured in *package.toml*'s `targets.elm.*` fields.


### `repository` (required): Git repository to serve the compiled package

It's used as `"repository"` field of a generated *package.json* manifest.
It should refer to the repository of a *generated* Elm package,
*not the Nirum source package*.  Read the "caveats" above as well.


Translation
-----------

 -  A Nirum module is translated to an Elm module.  A module name becomes
    PascalCase.  If a Nirum module's path is `foo-bar.baz` (*foo-bar/baz.nrm*)
    its corresponding Elm module becomes `FooBar.Baz` (*src/FooBar/Baz.elm*).

 -  A type name also becomes PascalCase, e.g., `foo-bar` to `FooBar`.

 -  An `unboxed` type becomes a `type` with a single constructor which has
    the same name to the type and a single field.
    E.g., `unboxed person-name (text);` becomes
    `type PersonName = FooBar String`.

 -  An `enum` type becomes a `type` with multiple consturctors that all have
    no field.  Each constructor corresponds to a `enum` member.
    E.g., `enum business-entity = ltd | inc;` becomes
    `type BusinessEntity = Ltd | Inc`.

 -  A `record` type becomes a `type` with a single constructor which has
    the same name to the type.  A constructor has a parameter of a record,
    and the record consits of fields (in Elm) mapped to fields (in Nirum).
    E.g., `record point (float32 x, float32 y);` becomes to
    `type Point = Point { x : Float, y : Float }`.

 -  A `union` type is translated in the same way to a `record` type, but with
    multiple constructors.  Each constructor corresponds to a `union` tag.
    E.g., `union user = anonymous | named ( text name );` becomes
    `type User = Anonymous | Named { name : String }`.

 -  An `alias` to a type is translated to a `type alias`,
    e.g., `type foo-bar = text;` becomes `type alias FooBar = String`.

 -  An encoder (serializer) is named starting with a type name in camelCase and
    a trailing `Encoder`.  For example, a decoder for a type `foo-bar` is
    `fooBarEncoder`.
